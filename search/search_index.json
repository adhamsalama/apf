{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"SimpleAPI","text":"<p> SimpleAPI is a minimalistic, unopinionated, WSGI-compliant, microframework for Python, inspired by FastAPI &amp; Flask.</p> <p>Source Code: https://github.com/adhamsalama/simpleapi</p> <p>The features:</p> <ol> <li>Simple and easy to understand.</li> <li>Fully Typed.</li> <li>Automatic Validation.</li> <li>Tested.</li> </ol> <p>The drawbacks:</p> <ol> <li>Not battle-tested.</li> <li>No websockets support (yet!).</li> <li>Doesn't support async/await like FastAPI.</li> </ol>"},{"location":"index.html#installation","title":"Installation","text":"<p><code>pip install simplestapi</code></p> <p>Note that here it's \"simplestapi\" instead of \"simpleapi\". This is because the name \"simpleapi\" is already taken.</p> <p>You will also need to install gunicorn to run the application.</p> <p><code>pip install gunicorn</code></p>"},{"location":"index.html#note","title":"Note","text":"<p>SimpleAPI is made only for educational purposes, I have been using Python frameworks like Flask and Django for years, and most recently, FastAPI. I was inspired by FastAPI and decided to create a framework by myself to deepen my knowledge of how web frameworks work.</p> <p>That being said...</p> <p></p>"},{"location":"automatic_validation.html","title":"Automatic Validation","text":""},{"location":"automatic_validation.html#a-simple-example","title":"A simple example","text":"<pre><code>from simpleapi import SimpleAPI\n\napp = SimpleAPI()\n\n@app.post(\"/create-item\")\ndef create_item(name: str, price: int):\n    return {\"name\": name, \"price\": price}\n</code></pre> <p>Here we specified that the request body will have a field called \"name\" and its type will be a string, and a field called \"price\" and its type will be an integer.</p> <p>Open Postman or Insomnia (or any HTTP client you like) and send a post request to <code>http://localhost:8000/create-item</code> with the required porperties:</p> <p></p>"},{"location":"automatic_validation.html#not-sending-required-properties","title":"Not Sending Required Properties","text":"<p>So, that worked, but what happens if the request body doesn't match the arguments you specified?</p> <p>Lets remove the price field from the request body and send the request again and see what will happen:</p> <p></p> <p>SimpleAPI automatically validated the request body and returned an error response specifying that the request body didn't match the required arguments. In particular, the \"price\" field is missing.</p>"},{"location":"automatic_validation.html#sending-wrong-type-of-required-fields","title":"Sending Wrong Type of Required Fields","text":"<p>If you add the \"price\" field back, and make its value anything but an integer, SimpleAPI will return an error response specifying that the \"price\" field's value isn't of the required type.</p> <p>An example:</p> <p></p> <p>Note: this only supports int, float, str, and bool. For more complex types, check and following section about Pydantic models.</p>"},{"location":"automatic_validation.html#pydantic-models","title":"Pydantic Models","text":"<p>You can have more fine-grained control and specify objects using Pydantic BaseModels.</p> <p>An example:</p> <pre><code>from simpleapi import SimpleAPI\nfrom pydantic import BaseModel\n\nclass Person(BaseModel):\n    name: str\n    age: int\n    job: str\n    is_alive: bool\n\napp = SimpleAPI()\n\n@app.post(\"/add-person\")\ndef add_person(person: Person):\n    person.age += 1\n    return person\n</code></pre> <p></p> <p>If we for example removed the \"is_alive\" field, the automatic validation will handle it for us.</p> <p></p>"},{"location":"automatic_validation.html#query-validation","title":"Query validation","text":"<p>You can also specify query parmeters.</p> <pre><code>from simpleapi import Query\n\n@app.get(\"/query-type-hint\")\ndef query(\n    age: Query,\n    name: Query = \"adhom\",\n):\n    return JSONResponse(body={\"name\": name, \"age\": age})\n</code></pre> <p>In this example, we specified that we require a query parameter named age and another query parameter named name, which has a default value and return the queries .</p> <p>If name wasn't provided by the client, then the default value will be used.</p> <p>But if age wasn't provided, an error would be automatically returned.</p> <p></p> <p>If we provide the age query, we will get this response.</p> <p></p> <p>If we provide name and query, we will get this response.</p> <p></p> <p>Notice that because we provied a value for name, this value was passed to the function and was used instead of the default value.</p> <p>The Query type is a union of str and list[str].</p> <p>If we provide multiple values for the same query parameter, it will be passed to the function as an array. </p>"},{"location":"dynamic_routing.html","title":"Dynamic Routing","text":"<p>A framework wouldn't be useful if it didn't support dynamic routing.</p> <p>SimpleAPI supports dynamic routing using curly brackets.</p> <p>An example of dynamic routing:</p> <pre><code>from simpleapi import SimpleAPI, Request\n\napp = SimpleAPI()\n\n@app.get(\"/hello/{name}\")\ndef hello_person(request: Request):\n    name = request.params[\"name\"]\n    return f\"Hello, {name}!\"\n</code></pre> <p>Run it with <code>gunicorn main:app</code></p> <p>Open your browser at http://localhost:8000/hello/David.</p> <p>You will see the response: <code>Hello, David!</code></p> <p>If you're wondering who is David, it's Professor David J. Mallan of Harvard University, I owe him making me fall in love with Programming when I took his CS50 course!  </p>"},{"location":"features.html","title":"Features","text":""},{"location":"features.html#simple-and-easy","title":"Simple and easy.","text":"<p>SimpleAPI is a small framework with a small codebase, because of its simplicity, it's easy to use, and easy to understand.</p> <p>You can take a look at the source code to have a deeper look at what's going on</p>"},{"location":"features.html#fully-typed","title":"Fully Typed.","text":"<p>I was hugely inspired by FastAPI's use of Python's type annotations, it simply makes the developing experience so much easier because of the help from the IDE/Code Editor.  </p>"},{"location":"features.html#automatic-validation","title":"Automatic Validation","text":"<p>If you specify the required fields of the incoming request body and their types, SimpleAPI automatically validates the incoming request body and supplies your functions with the required arguments.</p> <p>If the request body doesn't contain the arguments you specified, or doesn't match the types you specified, SimpleAPI returns an error response with a message highlighting where the error occured and what is the cause.</p> <p>You can have more fine-grained control over your arguments if you use Pydantic. SimpleAPI will also validate the request body and return an error if it doesn't match your specified Pydantic models.</p>"},{"location":"features.html#tested","title":"Tested","text":"<p>There are over 27 tests for several parts of functionalities that SimpleAPI provides.</p>"},{"location":"first_steps.html","title":"First Steps","text":"<p>This tutorial shows you how to use SimpleAPI with most of its features, step by step.</p> <p>You can copy the code blocks to a file named <code>main.py</code> and run it with <code>gunicorn main:app</code>.</p> <p>The simplest SimpleAPI file looks like this:</p> <p>Create a file <code>main.py</code> with:</p> <pre><code>from simpleapi import SimpleAPI\n\napp = SimpleAPI()\n\n@app.get(\"/hello\")\ndef hello():\n    return \"Hello, world!\"\n</code></pre> <p>Run it with <code>gunicorn main:app</code></p> <p>Open your browser at http://localhost:8000/hello.</p> <p>You will see the response: <code>Hello, world!</code></p> <p>You can also specify other HTTP methods, for example:</p> <pre><code>@app.post(\"/hello\")\ndef hello_post():\n    return \"Hello, world!\"\n\n@app.put(\"/hello\")\ndef hello_put():\n    return \"Hello, world!\"\n\n@app.patch(\"/hello\")\ndef hello_patch():\n    return \"Hello, world!\"\n\n@app.delete(\"/hello\")\ndef hello_delete():\n    return \"Hello, world!\"\n</code></pre> <p>Notice that if your function doesn't need the request object, you can just not specify it as a parameter.</p>"},{"location":"middleware.html","title":"Middleware","text":"<p>SimpleAPI offers fine-grained control over middleware.</p> <p>There are 3 types of middleware:</p> <ol> <li>Global middleware.</li> <li>Router middleware.</li> <li>Function middleware.</li> </ol>"},{"location":"middleware.html#global-middleware","title":"Global Middleware","text":"<p>Global middleware is applied globally on all route handlers.</p> <p>It's defined as a normal function that takes a request as a parameter.</p> <p>Example:</p> <pre><code>from simpleapi import SimpleAPI, Request\n\ndef global_middleware(request: Request):\n\"\"\"Logger middleware\"\"\"\n    print(f\"Path: {request.path}\")\n\napp = SimpleAPI(middleware=[global_middleware])\n\n@app.get(\"/hello\")\ndef hello():\n    return \"Hello, world!\"\n</code></pre> <p>If you check the terminal, you will see this: <code>Path: /hello</code></p> <p>You can add as many middleware as you want to the middleware array. They will be executed in order.</p>"},{"location":"middleware.html#router-middleware","title":"Router Middleware","text":"<p>Router middleware is applied to all of the router's route handlers.</p> <p>Example:</p> <pre><code>from simpleapi import Router, Request\n\ndef router_middleware(request: Request):\n\"\"\"Logger middleware\"\"\"\n    print(f\"Path: {request.path}\"\n\nrouter = Router(middleware=[router_middleware])\n\n@router.get(\"/hello\")\ndef hello():\n    return \"Hello, router!\"\n</code></pre> <p>This will print the path of all router handlers under this specific router, it won't execute for any other route handlers that aren't under this specific router.</p>"},{"location":"middleware.html#function-middleware","title":"Function Middleware","text":"<p>Function middleware is applied to its specific function only.</p> <p>Example:</p> <pre><code>from simpleapi import SimpleAPI, Request\n\ndef function_middleware(request: Request):\n\"\"\"Logger middleware\"\"\"\n    print(\"This is the /hello route\")\n\napp = SimpleAPI()\n\n@app.get(\"/hello\", middleware=[function_middleware])\ndef hello():\n    return \"Hello, world!\"\n</code></pre>"},{"location":"request.html","title":"Request","text":"<p>The Request class contains severl useful properties.</p> <p>Properties:</p> <ul> <li>method (The request HTTP method)</li> <li>path (The request path).</li> <li>params (The route's dynamic parameters).</li> <li>form (The request body's form data).</li> <li>body (The request's JSON body).</li> <li>query (The request's query parameters).</li> <li>headers (The request's headers).</li> <li>cookies (The requests's cookies).</li> <li>extra (A dict to which middleware can add fields).</li> </ul> <p>Source Code: https://github.com/adhamsalama/simpleapi/blob/main/simpleapi/request.py</p>"},{"location":"response.html","title":"Responses","text":"<p>You can return strings, dicts, integers, floats, Pydantic models right in your view function and SimpleAPI will automatically handle returning them as HTTP responses.</p> <p>But what if you want more control?</p>"},{"location":"response.html#response","title":"Response","text":"<p>The Base Response class contains severl useful properties and methods. All response classes inherit this class.</p> <p>Properties:</p> <ul> <li>code (The response status code, default = 200)</li> <li>body (The response body)</li> <li>headers (The response headers).</li> <li>content_type (The response content-type, default = text/html; charset=UTF-8)</li> </ul> <p>Methods:</p> <ul> <li>set_header (Sets a response header).</li> <li>set_cookie (Sets a response cookie).</li> </ul>"},{"location":"response.html#jsonresponse","title":"JSONResponse","text":"<p>The JSON Response class inherits everything from the Response class, except it sets the response content-type to application/json by default.</p>"},{"location":"response.html#example","title":"Example","text":"<p>To return a response with a 404 status code and a body of \"Can't find this resource\", and the content-type as text/html:</p> <pre><code>from simpleapi import SimpleAPI, Response\n\napp = SimpleAPI()\n\n@app.get(\"/not-found\")\ndef not_found():\n    response = Response(\n        code=404,\n        body=\"Can't Find this resource\",\n        content_type=\"text/html; charset=UTF-8\"\n    )\n    return response\n</code></pre> <p>Or you could return the built-in NotFoundErrorResponse!</p> <pre><code>from simpleapi import SimpleAPI, NotFoundErrorResponse\n\napp = SimpleAPI()\n\n@app.get(\"/not-found\")\ndef not_found():\n    return NotFoundErrorResponse()\n</code></pre>"},{"location":"routers.html","title":"Routers","text":"<p>When your app gets bigger, it's a good idea to write different parts of it in separate files.</p> <p>You can do this using Routers.</p> <p>Create another file called <code>routers.py</code> and add the following code to it:</p> <pre><code>from simpleapi import Router\n\nrouter = Router()\n\n@router.get(\"/hello\")\ndef hello():\n    return \"Hello, router!\"\n</code></pre> <p>And in your <code>main.py</code> file:</p> <pre><code>from simpleapi import SimpleAPI\nfrom .routers import router\n\napp = SimpleAPI()\n\napp.add_router(prefix=\"/router\", router=router)\n</code></pre> <p>Open your browser at http://localhost:8000/router/hello.</p> <p>You will see a response that looks like this:</p> <p><code>Hello, router!</code></p>"}]}